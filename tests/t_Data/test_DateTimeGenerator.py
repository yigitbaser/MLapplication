"""
Tester
"""

import random
from typing import Tuple, Any
import pytest

from src.Data.DateTimeGenerator import DateTimeGenerator
from src.Data.DateTimeGenerator import is_leap


def _compare_samples(fun: Any, t_from: int, t_to: int, n_sample: int = 200, seed: int = 432) \
        -> bool:
    """
    This function compares samples that are generated by parameter fun.
    :param fun: Any. Function to be tested.
    :param t_from: int. Beginning of time interval.
    :param t_to: int. End of time interval.
    :param n_sample: int. Number of samples.
    :param seed: int. Number to use in random.seed fcn for consistency of test.
    :return bool. True if samples are same, false if not.
    """
    random.seed(seed)

    gen = {fun(t_from, t_to) for i in range(n_sample)}
    test = set(range(t_from, t_to + 1))

    return gen == test

def test_year_generator() -> None:
    """
    This function tests number of years for DateTimeGenerator functionality for years.
    """
    dtg = DateTimeGenerator()
    assert _compare_samples(dtg.generate_year, 2000, 2025)

def test_month_generator() -> None:
    """
    This function tests number of months for DateTimeGenerator functionality for months.
    """
    dtg = DateTimeGenerator()
    assert _compare_samples(dtg.generate_month, 1, 12)

@pytest.mark.parametrize("year, month, n_days",  # type:ignore
                         [(2020, 1, 31),
                          (2020, 2, 29),
                          (2020, 3, 31),
                          (2020, 4, 30),
                          (2020, 5, 31),
                          (2020, 6, 30),
                          (2020, 7, 31),
                          (2020, 8, 31),
                          (2020, 9, 30),
                          (2020, 10, 31),
                          (2020, 11, 30),
                          (2020, 12, 31),
                          (2021, 2, 28)
                          ])
def test_day_generator(year: int, month: int, n_days: int) -> None:
    """
    This function tests the number of days for DateTimeGenerator functionality for days.
    :param year: int. Year of the test data.
    :param month: int. Month of the test data.
    :param n_days: int. Number of days.
    """
    random.seed(5498)
    dsg = DateTimeGenerator()
    gen = {dsg.generate_day(year, month) for i in range(300)}
    test = set(range(1, n_days + 1))
    assert gen == test


@pytest.mark.parametrize("year_from, year_to, month_from, month_to, n_days",  # type:ignore
                         [(2020, 2020, 1, 1, 31),
                          (2020, 2020, 2, 2, 29),
                          (2020, 2020, 3, 3, 31),
                          (2020, 2020, 4, 4, 30),
                          (2020, 2020, 5, 5, 31),
                          (2020, 2020, 6, 6, 30),
                          (2020, 2020, 7, 7, 31),
                          (2020, 2020, 8, 8, 31),
                          (2020, 2020, 9, 9, 30),
                          (2020, 2020, 10, 10, 31),
                          (2020, 2020, 11, 11, 30),
                          (2020, 2020, 12, 12, 31),
                          (2019, 2019, 2, 2, 28)
                          ])
def test_generate_day(year_from: int, year_to: int, month_from: int, month_to: int, n_days: int) \
        -> None:
    """
    This function tests the DateTimeGenerator functionality if it
    generates expected number of days, months and years.
    :param year_from: int. Beginning date(in years) of time interval.
    :param year_to: int. End date(in years) of time interval.
    :param month_from: int. End date(in months) of time interval.
    :param month_to: int. End date(in months) of time interval.
    :param n_days: int. Number of days.
    """
    random.seed(87602)
    dsg = DateTimeGenerator()
    gen = {dsg.generate_date(year_from, year_to, month_from, month_to) for i in range(150)}
    (y, m, d) = zip(*gen)
    assert set(y) == {year_from}
    assert set(m) == {month_from}
    assert set(d) == set(range(1, n_days + 1))


@pytest.mark.parametrize("triplet, result",  # type:ignore
                         [
                             ((2019, 2, 29), 20190229),
                             ((2019, 12, 1), 20191201),
                             ((2019, 12, 12), 20191212),
                             ((2019, 3, 5), 20190305)
                         ])
def test_convert_triplet(triplet: Tuple[int, int, int], result: int) -> None:
    """
    This function tests if convert_triplet function works properly- Tuple[yyyy, m, d]
    to yyyymmdd works properly.
    :param triplet: Tuple[yyyy, m, d] to test.
    :param result: int. Expected date in format yyyymmdd.
    """
    dsg = DateTimeGenerator()
    assert dsg.convert_triplet(triplet) == result


def test_standard_leap_year() -> None:
    """
    This function tests is_leap function for a standart leap year.
    """
    assert is_leap(1996)


def test_non_standard_leap_year() -> None:
    """
    This function tests is_leap function for a non-standard leap year.
    """
    assert is_leap(2000)


def test_non_leap_year() -> None:
    """
    This function tests is_leap function for a non-leap year.
    """
    assert not is_leap(1997)


def test_non_standart_non_leap_year() -> None:
    """
    This function tests is_leap function for a non-standard non-leap year.
    """
    assert not is_leap(1900)
